import type { ComponentTree } from "./debugger"

// The root of the tree structure generated by buildComponentTree
export type ComponentTreeRoot = ComponentTree[]

/**
 * Represents a condition for matching props or state in a selector.
 */
interface AttributeCondition {
  /** The type of attribute to check ('prop' or 'state'). */
  type: "prop" | "state"
  /** The key of the prop or state variable. */
  key: string
  /** The expected value for an equality check. Undefined if only checking existence. */
  value?: string | number | boolean
  /** True if the condition only checks for the existence of the key. */
  exists: boolean
}

/**
 * Represents the parsed structure of a component selector.
 */
interface ParsedSelector {
  /** The name of the component to match. */
  componentName: string
  /** An array of conditions to apply to the component's props and state. */
  conditions: AttributeCondition[]
}

/**
 * Parses a component selector string into a structured representation.
 * Supports selectors like: ComponentName[propKey=value][state.stateKey=value][propExists]
 *
 * @param selector - The selector string.
 * @returns The parsed selector object or null if parsing fails.
 */
function parseSelector(selector: string): ParsedSelector | null {
  const nameMatch = selector.match(/^[A-Za-z0-9_]+/)
  if (!nameMatch) {
    console.error(
      `[queryComponentTree] Invalid selector: No component name found in "${selector}".`,
    )
    return null
  }
  const componentName = nameMatch[0]

  const conditions: AttributeCondition[] = []
  // Regex breakdown:
  // \[\s* : Match opening bracket and optional whitespace
  // (?:(prop|state)\.)? : Optionally capture 'prop' or 'state' followed by a dot
  // ([a-zA-Z0-9_]+) : Capture the attribute key (prop or state name)
  // \s* : Optional whitespace
  // (?:=\s*(['"]?)(.*?)\3)? : Optionally match '=', optional whitespace,
  //                          optional quote (capture), the value (capture), the same quote
  // \s*\] : Optional whitespace and closing bracket
  const conditionRegex = /\[\s*(?:(prop|state)\.)?([a-zA-Z0-9_]+)\s*(?:=\s*(['"]?)(.*?)\3)?\s*\]/g
  const existenceRegex = /\[\s*([a-zA-Z0-9_]+)\s*\]/g // Simpler regex for just [key] existence

  const conditionsString = selector.substring(componentName.length)
  let match
  let lastIndex = 0

  // First pass for equality checks or prefixed existence checks [prop.key] / [state.key]
  while ((match = conditionRegex.exec(conditionsString)) !== null) {
    const typeStr = match[1] // 'prop', 'state', or undefined
    const key = match[2]
    const quote = match[3] // '', '"', or "'"
    const valueStr = match[4] // The captured value or undefined if only existence check (e.g., [prop.name])

    let value: any
    const existsCheck = valueStr === undefined && typeStr !== undefined // True for [prop.key] or [state.key]
    const equalityCheck = valueStr !== undefined

    if (equalityCheck) {
      if (quote === "") {
        // Not quoted - attempt type inference
        if (valueStr === "true") value = true
        else if (valueStr === "false") value = false
        else if (/^\d+$/.test(valueStr) && !valueStr.startsWith("0"))
          value = parseInt(valueStr, 10) // Avoid octal issues
        else if (/^\d*\.\d+$/.test(valueStr)) value = parseFloat(valueStr)
        else if (/^0$|^-?0\.\d+$/.test(valueStr))
          value = parseFloat(valueStr) // Handle 0 and -0.x
        else value = valueStr // Treat as string otherwise
      } else {
        // Quoted - always string
        value = valueStr
      }
    }

    conditions.push({
      type: typeStr === "state" ? "state" : "prop", // Default to prop
      key,
      value,
      exists: !equalityCheck, // If it's not an equality check, it's an existence check
    })
    lastIndex = conditionRegex.lastIndex
  }

  // Reset lastIndex and perform second pass for simple existence checks like [key]
  // only on parts of the string not matched by the first regex.
  existenceRegex.lastIndex = 0 // Reset regex state
  conditionRegex.lastIndex = 0 // Reset regex state

  let remainingStringToCheck = conditionsString
  let offset = 0
  // Remove parts already matched by conditionRegex to avoid double-matching
  while ((match = conditionRegex.exec(conditionsString)) !== null) {
    remainingStringToCheck =
      remainingStringToCheck.substring(0, match.index - offset) +
      " ".repeat(match[0].length) + // Replace matched part with spaces
      remainingStringToCheck.substring(match.index - offset + match[0].length)
    offset = conditionsString.length - remainingStringToCheck.length
  }

  while ((match = existenceRegex.exec(remainingStringToCheck)) !== null) {
    // Avoid double matching if conditionRegex already handled it (e.g. [prop.key] vs [key])
    // Check if this match range was already blanked out by conditionRegex replacement
    let alreadyMatched = true
    for (let i = match.index; i < match.index + match[0].length; ++i) {
      if (remainingStringToCheck[i] !== " ") {
        alreadyMatched = false
        break
      }
    }
    if (alreadyMatched) continue

    conditions.push({
      type: "prop", // Assume prop for simple existence like [key]
      key: match[1],
      exists: true,
    })
  }

  // Basic validation: Check if all non-whitespace characters in conditionsString were part of a valid match
  const totalMatchedLength = conditions.reduce((sum, _, index, arr) => {
    // This calculation is complex; approximate by checking if conditionsString contains unmatched brackets
    return sum
  }, 0) // Simplified validation for now

  if (
    conditionsString.replace(conditionRegex, "").replace(existenceRegex, "").replace(/\s/g, "") !==
    ""
  ) {
    console.warn(
      `[queryComponentTree] Possible invalid condition syntax in selector: "${selector}". Proceeding with parsed conditions.`,
    )
  }

  return { componentName, conditions }
}

/**
 * Checks if a given node matches the parsed selector conditions.
 *
 * @param node - The ComponentTree node to check.
 * @param parsedSelector - The parsed selector containing component name and conditions.
 * @returns True if the node matches, false otherwise.
 */
function checkNode(node: ComponentTree, parsedSelector: ParsedSelector): boolean {
  if (node.name !== parsedSelector.componentName) {
    return false
  }

  for (const condition of parsedSelector.conditions) {
    const source = condition.type === "prop" ? node.props : node.state
    const key = condition.key

    if (source === null || source === undefined || !(key in source)) {
      // If checking for existence, this is a failure.
      // If checking for equality, it implies the key doesn't exist, also a failure.
      return false
    }

    if (!condition.exists) {
      // Equality check
      // Use == for potential type coercion flexibility, matching querySelector behavior?
      // Or strict === ? Let's start with strict.
      if (source[key] !== condition.value) {
        return false // Value doesn't match
      }
    }
    // If condition.exists is true, we just needed the key to be present, which it is.
  }

  return true // All conditions passed
}

/**
 * Queries the component tree (array) for the first node matching the selector.
 * Performs a depth-first search.
 *
 * @param tree - The component tree array (output of buildComponentTree).
 * @param selector - The selector string (e.g., "MyComponent[prop=value][state.count=1]").
 * @returns The first matching ComponentTree node or null if not found.
 */
export function queryComponentTree(
  tree: ComponentTreeRoot | null | undefined,
  selector: string,
): ComponentTree | null {
  if (!tree) return null

  const parsedSelector = parseSelector(selector)
  if (!parsedSelector) return null

  function findRecursive(nodes: ComponentTree[]): ComponentTree | null {
    for (const node of nodes) {
      // Check if the current node matches the selector
      if (checkNode(node, parsedSelector!)) {
        // Non-null assertion ok due to check above
        return node // Found the first match
      }

      // If not a match, search in children (if they exist and are not empty)
      if (node.children && node.children.length > 0) {
        const foundInChildren = findRecursive(node.children)
        if (foundInChildren) {
          return foundInChildren // Found in descendants
        }
      }
    }
    return null // Not found at this level or its descendants
  }

  return findRecursive(tree)
}
